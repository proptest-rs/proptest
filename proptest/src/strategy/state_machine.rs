//-
// Copyright 2021 The proptest developers
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! Strategies used for abstract state machine testing.

use super::BoxedStrategy;
use crate::bits::{BitSetLike, VarBitSet};
use crate::collection::SizeRange;
use crate::num::sample_uniform_incl;
use crate::std_facade::fmt::{Debug, Formatter, Result};
use crate::std_facade::Vec;
use crate::strategy::{
    traits::{NewTree, ValueTree},
    Strategy,
};
use crate::test_runner::TestRunner;
use core::cell::Cell;

/// This trait is used to model system under test as an abstract state machine.
pub trait AbstractStateMachine {
    /// The abstract state machine's state type
    type State: Clone + Debug;
    /// The abstract state machine's transition type (typically an enum)
    type Transition: Clone + Debug;

    // TODO Instead of the boxed strategies, this could use
    // <https://github.com/rust-lang/rust/issues/63063> once stabilized:
    // type StateStrategy = impl Strategy<Value = Self::State>;
    // type TransitionStrategy = impl Strategy<Value = Self::Transition>;

    /// The initial state may be generated by any strategy. For a constant
    /// initial state, use [`proptest::strategy::Just`].
    fn init_state() -> BoxedStrategy<Self::State>;

    /// Generate the initial transitions.
    fn transitions(state: &Self::State) -> BoxedStrategy<Self::Transition>;

    /// Apply a transition in the abstract state.
    fn apply_abstract(
        state: Self::State,
        transition: &Self::Transition,
    ) -> Self::State;

    /// Pre-conditions may be specified to control which transitions are valid
    /// from the current state. If not overridden, this allows any transition.
    /// The pre-conditions are checked in the generated transitions and during
    /// shrinking.
    ///
    /// The pre-conditions checking relies on proptest global rejection
    /// filtering, which comes with some [disadvantages](https://altsysrq.github.io/proptest-book/proptest/tutorial/filtering.html).
    /// This means that pre-conditions that are hard to satisfy might slow down
    /// the test or even fail by exceeding the maximum rejection count.
    fn preconditions(
        #[allow(unused_variables)] state: &Self::State,
        #[allow(unused_variables)] transition: &Self::Transition,
    ) -> bool {
        true
    }

    /// A sequential strategy runs the state machine transitions generated from
    /// the abstract model sequentially in a test over a concrete state, which
    /// can be implemented with the help of [`StateMachineTest`] trait.
    fn sequential_strategy(
        size: impl Into<SizeRange>,
    ) -> Sequential<
        Self::State,
        Self::Transition,
        BoxedStrategy<Self::State>,
        BoxedStrategy<Self::Transition>,
    > {
        Sequential {
            size: size.into(),
            init_state: Self::init_state,
            preconditions: Self::preconditions,
            transitions: Self::transitions,
            next: Self::apply_abstract,
        }
    }
}

/// In a sequential state machine strategy, we first generate an acceptable
/// sequence of transitions. That is a sequence that satisfies the given
/// pre-conditions. The acceptability of each transition in the sequence only
/// depends on the current state of the state machine, which is updated by the
/// transitions with the `next` function.
///
/// The shrinking strategy is to iteratively apply `Shrink::InitialState`,
/// `Shrink::DeleteTransition` and `Shrink::Transition`.
///
/// 1. We start by trying to shrink the initial state, until it's not possible
///    to shrink it any further.
/// 2. Then, we try to delete transitions from the back of the list, until we
///    can do so no further (the list has reached the `min_size`).
/// 3. After that, we again iteratively attempt to shrink the individual
///    transitions, but this time starting from the front of the list from the
///    first transition to be applied.
///
/// For `complicate`, we attempt to undo the last shrink operation, if there was
/// any.
pub struct Sequential<
    State: Clone + Debug,
    // Debug required by Strategy::Value
    Transition: Clone + Debug,
    StateStrategy: Strategy<Value = State>,
    TransitionStrategy: Strategy<Value = Transition>,
> {
    size: SizeRange,
    init_state: fn() -> StateStrategy,
    preconditions: fn(state: &State, transition: &Transition) -> bool,
    transitions: fn(state: &State) -> TransitionStrategy,
    next: fn(state: State, transition: &Transition) -> State,
}

impl<
        State: Clone + Debug,
        Transition: Clone + Debug,
        StateStrategy: Strategy<Value = State>,
        TransitionStrategy: Strategy<Value = Transition>,
    > Debug
    for Sequential<State, Transition, StateStrategy, TransitionStrategy>
{
    fn fmt(&self, f: &mut Formatter) -> Result {
        f.debug_struct("Sequential")
            .field("size", &self.size)
            .finish()
    }
}

impl<
        State: Clone + Debug,
        Transition: Clone + Debug,
        StateStrategy: Strategy<Value = State>,
        TransitionStrategy: Strategy<Value = Transition>,
    > Strategy
    for Sequential<State, Transition, StateStrategy, TransitionStrategy>
{
    type Tree = SequentialValueTree<
        State,
        Transition,
        StateStrategy::Tree,
        TransitionStrategy::Tree,
    >;
    type Value = (State, Vec<TransitionStrategy::Value>);

    fn new_tree(&self, runner: &mut TestRunner) -> NewTree<Self> {
        // Generate the initial state value tree
        let initial_state = (self.init_state)().new_tree(runner)?;
        let last_valid_initial_state = initial_state.current();

        let (min_size, end) = self.size.start_end_incl();
        // Sample the maximum number of the transitions from the size range
        let max_size = sample_uniform_incl(runner, min_size, end);
        let mut transitions = Vec::with_capacity(max_size);
        let mut acceptable_transitions = Vec::with_capacity(max_size);
        let included_transitions = VarBitSet::saturated(max_size);
        let shrinkable_transitions = VarBitSet::saturated(max_size);

        // Sample the transitions until we reach the `max_size`
        let mut state = initial_state.current();
        while transitions.len() < max_size {
            // Apply the current state to find the current transition
            let transition_tree =
                (self.transitions)(&state).new_tree(runner)?;
            let transition = transition_tree.current();

            // If the pre-conditions are satisfied, use the transition
            if (self.preconditions)(&state, &transition) {
                transitions.push(transition_tree);
                state = (self.next)(state, &transition);
                acceptable_transitions
                    .push((Cell::new(TransitionState::Current), transition));
            } else {
                runner.reject_local("Pre-conditions were not satisfied")?;
            }
        }

        // The maximum index into the vectors and bit sets
        let max_ix = max_size - 1;

        Ok(SequentialValueTree {
            initial_state,
            is_initial_state_shrinkable: true,
            last_valid_initial_state,
            preconditions: self.preconditions,
            next: self.next,
            transitions,
            acceptable_transitions,
            included_transitions,
            shrinkable_transitions,
            min_size,
            max_ix,
            // On a failure, we start by shrinking transitions from the back
            // which is less likely to invalidate pre-conditions
            shrink: Shrink::DeleteTransition(max_ix),
            prev_shrink: None,
        })
    }
}

/// A shrinking operation
#[derive(Clone, Copy, Debug)]
enum Shrink {
    /// Shrink the initial state
    InitialState,
    /// Delete a transition at given index
    DeleteTransition(usize),
    /// Shrink a transition at given index
    Transition(usize),
}
use Shrink::*;

/// The state of a transition in the model
#[derive(Clone, Copy, Debug)]
enum TransitionState {
    /// The transition that is equal to the result of `ValueTree::current()`
    /// and satisfies the pre-conditions
    Current,
    /// The transition has been simplified, but rejected by pre-conditions
    SimplifyRejected,
    /// The transition has been complicated, but rejected by pre-conditions
    ComplicateRejected,
}
use TransitionState::*;

/// The generated value tree for a sequential state machine.
pub struct SequentialValueTree<
    State: Clone + Debug,
    Transition: Clone + Debug,
    StateValueTree: ValueTree<Value = State>,
    TransitionValueTree: ValueTree<Value = Transition>,
> {
    /// The initial state value tree
    initial_state: StateValueTree,
    /// Can the `initial_state` be shrunk any further?
    is_initial_state_shrinkable: bool,
    /// The last initial state that has been accepted by the pre-conditions.
    /// We have to store this every time before attempt to shrink
    last_valid_initial_state: State,
    /// The pre-conditions predicate
    preconditions: fn(&State, &Transition) -> bool,
    /// The function from current state and a transition to an updated state
    next: fn(State, &Transition) -> State,
    /// The list of transitions' value trees
    transitions: Vec<TransitionValueTree>,
    /// The sequence of included transitions that satisfy the pre-conditions
    acceptable_transitions: Vec<(Cell<TransitionState>, Transition)>,
    /// The bit-set of transitions that have not been deleted by shrinking
    included_transitions: VarBitSet,
    /// The bit-set of transitions that can be shrunk further
    shrinkable_transitions: VarBitSet,
    /// The minimum number of `transitions`
    min_size: usize,
    /// The maximum index in the `transitions` vector (its size - 1)
    max_ix: usize,
    /// The next shrink operation to apply
    shrink: Shrink,
    /// The previously applied shrink operation, if any
    prev_shrink: Option<Shrink>,
}

impl<
        State: Clone + Debug,
        Transition: Clone + Debug,
        StateValueTree: ValueTree<Value = State>,
        TransitionValueTree: ValueTree<Value = Transition>,
    >
    SequentialValueTree<State, Transition, StateValueTree, TransitionValueTree>
{
    /// The currently included and acceptable transitions. When `ix` is not
    /// `None`, the transition at this index is taken from its current value
    /// (which may  not be acceptable by the pre-conditions), instead of its
    /// acceptable value.
    fn current_transitions_at(&self, ix: Option<usize>) -> Vec<Transition> {
        self.acceptable_transitions
            .iter()
            .enumerate()
            // Filter out deleted transitions
            .filter(|&(this_ix, _)| self.included_transitions.test(this_ix))
            // Map the indices to the values
            .map(|(this_ix, (_, transition))| match ix {
                Some(ix) if this_ix == ix => self.transitions[ix].current(),
                _ => transition.clone(),
            })
            .collect()
    }

    /// Find if the initial state is still shrinkable and if all the
    /// simplifications and complications of the included transitions have been
    /// rejected.
    fn is_simplifiable(&self) -> bool {
        self.is_initial_state_shrinkable ||
             // If there are some transitions whose shrinking has not yet been 
             // rejected, we can try to shrink them further
             !self
                .acceptable_transitions
                .iter()
                .enumerate()
                // Filter out deleted transitions
                .filter(|&(ix, _)| self.included_transitions.test(ix))
                .all(|(_, (state, _transition))| {
                    matches!(state.get(), SimplifyRejected | ComplicateRejected)
                })
    }

    /// Try to apply the next `self.shrink`. Returns `true` is a shrink has been
    /// applied.
    fn try_simplify(&mut self) -> bool {
        if let DeleteTransition(ix) = self.shrink {
            if self.included_transitions.count() == self.min_size {
                // Can't delete any more transitions, move on to shrinking them
                self.shrink = Transition(0);
            } else {
                // Delete the index from the included transitions
                self.included_transitions.clear(ix);

                self.prev_shrink = Some(self.shrink);
                self.shrink = if ix == 0 {
                    // Reached the beginning of the list, move on to shrinking
                    Transition(0)
                } else {
                    // Try to delete the previous transition next
                    DeleteTransition(ix - 1)
                };
                // If this delete is not acceptable, undo it and try again
                if !self.check_acceptable(None) {
                    self.included_transitions.set(ix);
                    self.prev_shrink = None;
                    return self.try_simplify();
                }
                self.shrinkable_transitions.clear(ix);
                return true;
            }
        }

        while let Transition(ix) = self.shrink {
            if self.shrinkable_transitions.count() == 0 {
                // Move on to shrinking the initial state
                self.shrink = Shrink::InitialState;
                break;
            }

            if !self.included_transitions.test(ix) {
                // No use shrinking something we're not including
                self.shrink = self.next_shrink_transition(ix);
                continue;
            }

            if let SimplifyRejected = self.acceptable_transitions[ix].0.get() {
                // This transition is already simplified and rejected
                self.shrink = self.next_shrink_transition(ix);
            } else if self.transitions[ix].simplify() {
                self.prev_shrink = Some(self.shrink);
                if self.check_acceptable(Some(ix)) {
                    self.acceptable_transitions[ix] =
                        (Cell::new(Current), self.transitions[ix].current());
                    return true;
                } else {
                    self.acceptable_transitions[ix].0.set(SimplifyRejected);
                    self.shrink = self.next_shrink_transition(ix);
                    return self.simplify();
                }
            } else {
                self.shrinkable_transitions.clear(ix);
                self.shrink = self.next_shrink_transition(ix);
            }
        }

        if let InitialState = self.shrink {
            if self.initial_state.simplify() {
                if self.check_acceptable(None) {
                    // Store the valid initial state
                    self.last_valid_initial_state =
                        self.initial_state.current();
                    return true;
                } else {
                    // If the shrink is not acceptable, clear it out
                    self.prev_shrink = None;
                }
            }
            self.is_initial_state_shrinkable = false;
            // Nothing left to do
            return false;
        }

        // This statement should never be reached
        panic!("Unexpected shrink state");
    }

    /// Find the next shrink transition. Loops back to the front of the list
    /// when the end is reached.
    fn next_shrink_transition(&mut self, current_ix: usize) -> Shrink {
        if current_ix == self.max_ix {
            // Either loop back to the start of the list...
            Transition(0)
        } else {
            // ...or move on to the next transition
            Transition(current_ix + 1)
        }
    }

    /// Check if the sequence of included transitions is acceptable by the
    /// pre-conditions. When `ix` is not `None`, the transition at the given
    /// index is taken from its current value.
    fn check_acceptable(&mut self, ix: Option<usize>) -> bool {
        let transitions = self.current_transitions_at(ix);
        let mut state = self.last_valid_initial_state.clone();
        for transition in transitions.iter() {
            let current_acceptable = (&self.preconditions)(&state, transition);
            if current_acceptable {
                state = (&self.next)(state, transition);
            } else {
                return false;
            }
        }
        true
    }

    /// Find if there's any acceptable included transition that is not current,
    /// starting from the given index. Expects that all the included transitions
    /// are currently being rejected (when `is_simplifiable` returns `false`).
    fn try_to_find_acceptable(&mut self, ix: usize) -> bool {
        let mut ix_to_check = ix;
        loop {
            if self.included_transitions.test(ix_to_check)
                && self.check_acceptable(Some(ix_to_check))
            {
                self.acceptable_transitions[ix_to_check] = (
                    Cell::new(Current),
                    self.transitions[ix_to_check].current(),
                );
                return true;
            }
            // Move on to the next transition
            if ix_to_check == self.max_ix {
                ix_to_check = 0;
            } else {
                ix_to_check += 1;
            }
            // We're back to where we started, there nothing left to do
            if ix_to_check == ix {
                return false;
            }
        }
    }
}

impl<
        State: Clone + Debug,
        Transition: Clone + Debug,
        StateValueTree: ValueTree<Value = State>,
        TransitionValueTree: ValueTree<Value = Transition>,
    > ValueTree
    for SequentialValueTree<
        State,
        Transition,
        StateValueTree,
        TransitionValueTree,
    >
{
    type Value = (State, Vec<Transition>);

    fn current(&self) -> Self::Value {
        // The current included acceptable transitions
        (
            self.last_valid_initial_state.clone(),
            self.current_transitions_at(None),
        )
    }

    fn simplify(&mut self) -> bool {
        if self.is_simplifiable() {
            self.try_simplify()
        } else {
            if let Some(Transition(ix)) = self.prev_shrink {
                return self.try_to_find_acceptable(ix);
            }
            false
        }
    }

    fn complicate(&mut self) -> bool {
        match self.prev_shrink {
            None => false,
            Some(DeleteTransition(ix)) => {
                // Undo the last item we deleted. Can't complicate any further,
                // so unset prev_shrink.
                self.included_transitions.set(ix);
                self.shrinkable_transitions.set(ix);
                self.prev_shrink = None;
                true
            }
            Some(Transition(ix)) => {
                if self.transitions[ix].complicate() {
                    if self.check_acceptable(Some(ix)) {
                        self.acceptable_transitions[ix] = (
                            Cell::new(Current),
                            self.transitions[ix].current(),
                        );
                        // Don't unset prev_shrink; we may be able to complicate
                        // it again
                        return true;
                    } else {
                        self.acceptable_transitions[ix]
                            .0
                            .set(ComplicateRejected);
                    }
                }
                // Can't complicate the last element any further
                self.prev_shrink = None;
                false
            }
            Some(InitialState) => {
                self.prev_shrink = None;
                if self.initial_state.complicate()
                    && self.check_acceptable(None)
                {
                    self.last_valid_initial_state =
                        self.initial_state.current();
                    // Don't unset prev_shrink; we may be able to complicate
                    // it again
                    return true;
                }
                // Can't complicate the initial state any further
                self.prev_shrink = None;
                false
            }
        }
    }
}
